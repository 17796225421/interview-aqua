基数排序 RadixSort

\1. 基数排序。

假设我们要对 10 万个手机号码进行排序，手机号码有 11 位，范围太大（ ），显然桶排序和计数排序是不适合用。

 

类似手机号码的排序，是有规律的，比如 a 前几位比 b 大，那么后面几位就可以不用看了。

 

借助稳定排序算法，我们可以先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。// 基数排序的实现思路。

 

注意，这里要使用稳定的排序算法，因为到排序第一位时，如果是不稳定的排序算法，那么我们之前所排序的低位就没有了意义。

 

// 基数排序的时间复杂度。

根据每一位来排序，我们可以用桶排序或计数排序，它们的时间复杂度可以做到 O(N)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。

 

有时候排序的数据并不都是等长的，比如排序牛津词典。这个时候我们可以将所有单词补齐到相同长度。位数不够的在后面补“0”，因为根据 ASCII 值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。

 

// 注意，字典中的顺序不考虑长度，比如 abf 排在 abbs 前面。



\2. 基数排序的适用场景。

①待排序数据可以分割出独立的“位”来比较，且位之间有递进的关系。比如电话号码。

②每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。// 计数排序的要求是范围不能太大