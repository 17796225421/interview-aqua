均匀硬币，产生不等概率
现有一枚均匀的硬币 coin()，能够返回 0、1 两个值，其概率均为 0.5。要求编写一个函数 coin_new()，使得它返回指定的 0、1 概率分布。


// 均匀硬币
int coin() {
    return rand() % 2;
}
P(0) = 1/4，P(1) = 3/4
对于均匀硬币而言，连续抛两次，得到 0 0、0 1、1 0、1 1 的概率均为 1/4。显然，只需要连续抛两次硬币，如果得到 0 0，返回 0，其他情况返回 1。


int coin_new() {
    return coin() || coin();
}
测试输出：


0: 0.249249
1: 0.750751
P(0) = 1/3，P(1) = 2/3
连续抛两次硬币。如果得到 1 1，返回 0；如果得到 1 0 或 0 1，返回 1；如果得到 0 0，继续抛硬币。


int coin_new() {
    while (true) {
        int a = coin(), b = coin();
        if (a && b) return 0;
        if (a || b) return 1;
    }
}
测试输出：


0: 0.333663
1: 0.666337
P(0) = 0.3，P(1) = 0.7
每抛一次硬币，会得到二进制数的一位
连续抛 4 次硬币，可以等概率生成 [0, 15] 的每个数，记为 xx
去掉 [10, 15]，剩下 [0, 9] 的每个数依然是等概率的
如果 x \in [0, 2]x∈[0,2]，返回 0；x \in [4, 9]x∈[4,9]，返回 1；x ≥ 10x≥10，重复上述过程

int coin_new() {
    while (true) {
        int x = 0;
        for (int i = 0; i < 4; i++) {
            x = (x << 1) + coin();
        }
        if (x <= 2) return 0;
        if (x <= 9) return 1;
    }
}
测试输出：


0: 0.300324
1: 0.699676
总结
不难发现，上面这三道题目其实都是同一种思路：

每抛一次硬币，会得到二进制数的一位
连续抛 kk 次硬币，可以等概率生成 [0, 2^k-1][0,2 
k
 −1] 的每个数
在 [0, 2^k-1][0,2 
k
 −1] 中，选取 mm 个数返回 0，nn 个数返回 1，则 0、1 的概率分别为 \frac{m}{m+n} 
m+n
m

 、\frac{n}{m+n} 
m+n
n


关于 kk 的选择，最少需要满足 N <= 2^k-1N<=2 
k
 −1，N 是生成对应概率分布至少需要多少个不同数字。比如要生成 1/3、2/3 的分布，至少需要 3 个不同数字，则 N = 3, k = 2N=3,k=2；要生成 3/10、7/10 的分布，至少需要 10 个数字，则 N = 10, k = 4N=10,k=4。

kk 最多则没有限制，我们总可以通过抛更多次硬币来解决问题，只需要把无用的数字舍弃即可。但我们的目的是尽可能减少无用数字的比例，因为每次遇到无用数字时，都需要重新生成新的数字。

