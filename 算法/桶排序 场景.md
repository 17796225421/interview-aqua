根据前面时间复杂度的推导，我们会发现，可以进行桶排序的场景要求很高。

首先，它要求数据可以较为均匀地分布到每个桶里。假如某些桶的数据相比其它桶非常少，其实等同于将它被合并放到另一个桶里，本质就是少了一个桶，m 就会变小，n/m 就会接近于 n。一种极端情况下，数据全放到一个桶里，时间复杂度就退化为 O(nlogn)。

虽然一般情况下，能用桶排序的场景比较少，但有一种场景就很适合桶排序，那就是 **外部排序**。

外部排序（External sorting）是指能够处理极大量数据的排序算法。通常外部排序会用到外存。在数据量很大，内存无法一次全部读取的情况下，就需要用到外部排序。除了可以用 桶排序，我们还可以用 **归并排序** 来做外部排序。

假设我们有一个很大的文件，里面保存了很多数据，要对它们进行排序，具体做法是：

1. 扫描大文件的数据得到数值范围，确定合适的桶的数量（保证 n/m 的数据量可以一次读入到内存中）。这里的桶会对应一个个小文件。
2. 从头往后扫描大文件，将数据按照范围放到小文件中。
3. 每个小文件的数据全部读取到内存中，进行排序。这里注意使用的排序算法是否为原地排序，且是否为稳定排序。具体根据实际情况进行选择合适的排序算法。另外，如果小文件里的数据（一般来说是数据分布不均匀导致的）仍不能一次读取到内存中，可以对小文件继续进行拆分，得到第二小文件。
4. 按顺序合并多个小文件为一个大的文件。





\1. 桶排序。

桶排序的思想是，将待排序序列划分到几个有序的桶中，然后分别对每个桶的数据单独排序。最后按照桶的顺序依次将桶里的元素取出，最后组成的序列就是有序的了。

![img](image/fc2fee7762f99e407f1dad22901c4252.png)



桶排序是线性排序，时间复杂度是 O(N)

我们将 n 个数据划分到 k 个桶中，然后对每个桶单独进行快排。可以得到：O(k * n/k * log(n/k) )=O(n * log(n/k) )，当桶的数量 k 接近数据个数 n 时，log(n/k) 就是一个非常小的常量，此时桶排序的时间复杂度接近 O(N)

 

\2. 桶排序的适用场景。

①待排序序列能轻易的划分出 n 个桶，并且桶与桶之间天然有大小顺序；

②数据比较均匀地分布在各个桶中；极端情况下都分布在一个桶中，退化成 O(NlogN)

③桶排序适用于外部排序。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。

 

\3. 假设我们有 10GB 的订单数据，我们希望按照订单金额大小排序。而这 10G 的数据无法一次性加载进内存，此时我们可以借助桶排序。

首先，扫描一遍文件，得到订单金额所处的范围，假设最小值为 1，最大值是 10 万。

接着，我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元的订单，以此类推。

 

理想的情况下，订单金额均匀分布，订单会被均匀地划分到 100 个文件中，每个小文件大约 100MB，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。

 

最后依次取出桶里边的每个元素输出到一个文件夹中。当然，订单金额不均匀，可能出现单个桶太大无法加载至内存中，我们可以按照同样的思路，对这个桶继续划分，比如是[1,1000]的桶太大，那么我们可以将[1,1000]的桶划分成 10 个区间。[1,100]、[101,200]……直至所有桶都能读进内存为止。
