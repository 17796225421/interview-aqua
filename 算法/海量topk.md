### 一，找出不重复的

在`2.5亿`个`正整数`中找出不重复的整数。

#### 思路一：

#### `分治法 + HashMap` (HashMap 不要局限在 Java 语言)

将 2.5 亿个整数，分批操作，例如分成 250 万一批，共100批次。每批使用循环遍历一次，存入 `HashMap<int1,int2>` 里面，`int1` 对应这个数，`int2` 对应它出现的次数，没出现就默认是 1 次。每操作完一批，就进行当前的 `HashMap` 的`去重操作`，读出 `int2 > 1` 的，排除掉。接下来的批次，以此类推，得出 100，剩下的自然就是不重复的。

#### 好了，我们现在来计算下上面这个方案的双间复杂度，`时间` & `空间`

`时间复杂度`：`250W * 100轮 + 其它批次`。对于多核机器，可以启动线程操作。

`空间复杂度`：使用 int 来进行存每一个数，保证不溢出情况下，那么就是 --> `Key + Value : (250W * 4字节，4Byte)/(1024*1024) ~ (Key + 9.5MB)` 内存。

#### 思路二：

#### `位图法 Bitmap`(一个 bit 仅会是 0 或 1)

对于此题，我们可以设计每两个 `bit` 位，标示一个数的出现情况。`00`表示没有出现，`01`表示出现一次，`10`表示出现多次。2.5 亿个正整数，首先我们要知道是`正整数`，我们就不需要考虑负数，也就是无符号，`无符号的整形占四个字节`。

##### 我们以这个为例子，开始计算`位图`内存。

1B = 8b，4B = 32b，它可以表示的`最大`的整数是 `2^32-1(不溢出)`，也就是说，我们需要 `2^32-1 ~ 2^32` 个`位`来表示这`2.5`亿个数。我们上面说了，`每个状态`是两个`位`，那么总共就是`2^32*2`个位。

那么我们可以一次申请的 位图 内存是：`2^32*2 bit ，(2^32*2)/(1024*1024*8) = 1GB` 即可。当然，我们也可以加上`分治`的思路，分批处理，不用直接用 1G，哈哈。

那么这样做的情况下怎样找到这个数呢？我举个例子，例如我们此时读入一个数是：`64`，`64`对应的所在`bit`位是：`64*2=128`，也就是说第 `127` 和 `128` 位共同`标示了它的出现状态`。其他的以此类推。每当我们读出一个数，我们就这样去找到它对应的`bit位`，先读出`bit位`的值，再做记录，已经是`01`的，再次来到，那么就应该修改为`10`。最后的我们这样得出结果：扫描整个位图，如果是`10`的，就`下标/2`得出这个数。


