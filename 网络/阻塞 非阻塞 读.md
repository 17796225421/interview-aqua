**read 的原则：**

　　数据在不超过指定的长度的时候有多少读多少，没有数据就会一直等待。所以一般情况下::我们读取数据都需要采用循环读的方式读取数据，因为一次read 完毕不能保证读到我们需要长度的数据，read 完一次需要判断读到的数据长度再决定是否还需要再次读取。

**阻塞情况下**

　　在阻塞条件下，read/recv/msgrcv的行为:

1. 如果没有发现数据在网络缓冲中会一直等待，
2. 当发现有数据的时候会把数据读到用户指定的缓冲区，但是如果这个时候读到的数据量比较少，比参数中指定的长度要小，read 并不会一直等待下去，而是立刻返回

**非阻塞情况下**
    在非阻塞的情况下，read 的行为

1. 如果发现没有数据就直接返回，
2. 如果发现有数据那么也是采用有多少读多少的进行处理．

　　所以read 完一次需要判断读到的数据长度再决定是否还需要再次读取。
**对于读而言：阻塞和非阻塞的区别在于没有数据到达的时候是否立刻返回．**
    recv 中有一个MSG_WAITALL 的参数
    recv(sockfd, buff, buff_size, MSG_WAITALL),
    在正常情况下recv 是会等待直到读取到buff_size 长度的数据，但是这里的WAITALL 也只是尽量读全，在有中断的情况下recv 还是可能会被打断，造成没有读完指定的buff_size的长度。
    所以即使是采用recv + WAITALL 参数还是要考虑是否需要循环读取的问题，在实验中对于多数情况下recv (使用了MSG_WAITALL)还是可以读完buff_size，
    所以相应的性能会比直接read 进行循环读要好一些。

**注意** 

　　使用MSG_WAITALL时，sockfd必须处于阻塞模式下，否则不起作用。
　　所以MSG_WAITALL不能和MSG_NONBLOCK同时使用。
    要注意的是使用MSG_WAITALL的时候，sockfd 必须是处于阻塞模式下，否则WAITALL不能起作用。