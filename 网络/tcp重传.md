# TCP 的重传机制

TCP实现可靠传输的方的核心就是通过**序号**与**确认序号**。但是针对网络环境较差可能存在数据丢包的情况下，使用重传机制来解决：

- 超时重传
- 快速重传
- SACK
- D-SACK

**超时重传**
重传机制的其中一个方式，就是在发送数据时，设定一个定时器，**当超过指定的时间后，没有收到对方的 `ACK` 确认应答报文，就会重发该数据**，也就是我们常说的超时重传。

TCP 会在以下两种情况发生超时重传：

- 数据包丢失：接收端没有接收到数据
- 确认应答丢失：接收到数据，但是返回的`ACk 端没有接收到

在超时重传在，关键在于如何计算超时重复时间(`Retransmission Timeout`, `RTO`)：

- 当超时时间 RTO 较大时，重发就慢，丢了老半天才重发，没有效率，性能差；
- 当超时时间 RTO 较小时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发

一般，`RTO`计算方式和包的往返时间(`Round-Trip Time, RTT`)相关（具体的计算方式，见相关书籍）。`RTO`是一个动态的计算方式，根据`RTT`变动。

> `RTT`计算的时间是：从发出数据包到接收到对端的`ACK`应答的时间

**快速重传**
快速重传的最大特点是**不以时间为驱动，而是以数据驱动重传**。

- 工作方式：快速重传的工作方式是**当发送端收到三个相同的 `ACK` 报文时，会在定时器过期之前，重传丢失的报文段**。
- 解决的问题：快速重传机制只解决了一个问题，就是超时时间的问题。但是它依然面临着另外一个问题：就是重传的时候，是重传之前的一个，还是重传所有的问题

在下图中，接收端没有收到`seq=2`的数据包，无论后面接收到什么数据，总是向发送端发送缺乏的那个数据包的应答`ACK=2`，发送端收到了三个 `ACK = 2` 的确认，知道了 `Seq2` 还没有收到，就会在定时器过期之前，重传丢失的 `Seq2`。

![img](image/快速重传.png)

但是，比如对于上面的例子，是重传 `Seq2` 呢？还是重传 `Seq2、Seq3、Seq4、Seq5` 呢？因为发送端并不清楚这连续的三个 `ACK 2` 是谁传回来的。

**SACK**
这个重传机制，就是为了解上面快速重传机制中存在问题。

这种方式需要在 TCP 头部 **「选项」** 字段里加一个 *SACK* 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。

如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 200~299 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重发。

![img](image/SACK.png)

**D-SACK**
`D-SACK`(`Duplicate SACK`)其主要使用了`SACK`来告诉「发送方」有哪些数据被重复接收了。

针对网络延迟和数据丢包，很有作用：

- 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;
- 可以知道是不是「发送方」的数据包被网络延迟了;