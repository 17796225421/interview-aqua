### 流量控制

为了防止发送端发送过多数据量导致接受端处理不过来，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。

发送方窗口大小会根据接受方的窗口大小进行动态的调整。

**窗口关闭**
TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。

> 窗口关闭存在的危险

接收方向发送方通告窗口大小时，是通过 ACK 报文来通告的。当发生窗口关闭时，接收方处理完数据后，接受端会向发送端通告一个窗口非 0 的 `ACK` 报文，如果这个通告窗口的 `ACK` 报文在网络中丢失了，这就会导致发送方一直等待非0的通知，而接受方在发出`ACK`之后就开始等待发送方的数据，如此就会产生死锁。

> 避免死锁

为了解决这个问题，TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送窗口探测 ( *Window probe* ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。

**Nagle算法** 发送方的数据只有几个字节，为了发送这几个字节却需要添加上**TCP+IP**共有40个字节的头部，开销很大。为此，需要禁止*Nagle*算法，不让小数据量单独发送，而是等几个小数据量合并为大的数据包再发送。

在 *socket* 设置 **TCP_NODELAY** 选项来关闭这个算法（关闭 *Nagle* 算法没有全局参数，需要根据每个应用自己的特点来关闭）

```cpp
int value=1;
setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, &value, sizeof(int));
```