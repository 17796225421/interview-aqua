**2. 服务器进程终止**

服务端终止，会给客户端发送一个**FIN**报文，客户端回应**ACK**。

因为客户端接受到 `FIN` 只是表示服务端不再发送数据，并不知道服务端已经终止。因此当客户端向已终止的服务端写数据时，之前响应打开的`socket` 已经关闭，因为服务会回应一个`RST` 给客户端。如果在收到 `RST` 之前调用`read`，会接收到未预料的`0`，表示`EOF`。如果在`RST`之后调用`read`会返回错误：`ECONNREST`，表示”对方服务连接错误。

**3. SIGPIPE**
针对上面的情况，如果客户端不理会服务器终止产生的错误，**继续**向已经关闭的socket里写入数据，就会触发`SIGPIPE`信号，这个信号的默认动作是终止当前进程。对于服务端需要捕获这个信号，以防止向一个已经关闭的socket写入数据，导致整个服务端进程终止。

向已经关闭的socket通道写数据：

- 第一次写，会返回 `RST`

- 第二次写，触发`SIGPIPE`信号

  不论该进程是捕获了该信号并从其信号处理函数处返回，还是选择简单的忽略该信号，写操作都是会返回错误：`EPIPE`。

**4. 服务器主机崩溃**
如果客户端向已经崩溃的服务器写数据，但此时的服务器已经崩溃。客户端的TCP试图接受到服务端的 `ACK`。但是没有接收到，因为不知道是因为服务器没有接收到还是因为网络拥塞导致没有达到，都会触发重传机制。经过多次重传，`Berkeley`实现是在尝试12次共9分钟后才放弃重传，会给客户端返回一个错误：`ETIMEOUT` 。

如果是中间某个路由器判定服务器主机已经是不可达，从而响应以`destination unreachable`的ICMP消息。错误就是 **EHOSTUNREACH / ENETUNREACH**。

**5. 服务器主机崩溃后重启**
如果服务端主机重启后接收到来自客户端的数据，因为之前的TCP信息已经全部丢失，服务端会响应一个 `RST` 报文信息。客户端会接调用 `read` 收到 `ECONNREST` 错误。

如果对于客户而言，检测服务器主机是否崩溃很重要，除了可以主动发送数据检测外，还可以采用`SO_KEEPLIVE`选项。