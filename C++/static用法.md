# 静态成员函数

静态成员函数被转换为非成员函数的方式:

```
    obj.normalized();   // normalize 7Point3dSFv(); 
    ptr->normalized();  // normalize 7Point3dSFv(); 
    // 实际上应该是由类直接调用静态函数，而不是类对象或者类指针
```

对象调用和指针调用可见完全一样，而且转换之后，不带有任何关乎调用这个静态函数的类信息，这也就说明了为什么不能在静态函数中直接调用“普通类成员”。

**静态成员函数的主要特性就是它没有`this`指针**，次要特性：

- 不能够直接存取所属类中的非静态成员函数
- 不能被声明为`const`、 `virtual`、 `volatile`。
- 不需要通过类对象来调用

如果获取一个静态成员函数的地址，获得的是这个静态成员函数在内存中的位置，也就是其地址。因为其没有`this`指针，所以地址类型是“指向非成员函数指针”，而不是“指向类成员函数指针”。即：

```
    &Point3d::object_count(); 
     // 得到一个数值，其类型是 unsigned int (*)();
     // 而不是 unsigned int (point3d::* )();
```



因此，缺乏`this`指针的静态成员函数，很大程度上等同于非成员函数。



------

#### [43、static的用法和作用？](https://interviewguide.cn/#/Doc/Knowledge/C++/基础语法/基础语法?id=43、static的用法和作用？)

1.先来介绍它的第一条也是最重要的一条：隐藏。（static函数，static变量均可）

当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性。

2.static的第二个作用是保持变量内容的持久。（static变量中的记忆功能和全局生存期）存储在静态数据区的变量会在程序刚开始运行时就完成初始化，也是唯一的一次初始化。共有两种变量存储在静态存储区：全局变量和static变量，只不过和全局变量比起来，static可以控制变量的可见范围，说到底static还是用来隐藏的。

3.static的第三个作用是默认初始化为0（static变量）

其实全局变量也具备这一属性，因为全局变量也存储在静态数据区。在静态数据区，内存中所有的字节默认值都是0x00，某些时候这一特点可以减少程序员的工作量。

4.static的第四个作用：C++中的类成员声明static

\1) 函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；

\2) 在模块内的static全局变量可以被模块内所有函数访问，但不能被模块外其它函数访问；

\3) 在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内；

\4) 在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；

\5) 在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量。

类内：

\6) static类对象必须要在类外进行初始化，static修饰的变量先于对象存在，所以static修饰的变量要在类外初始化；

\7) 由于static修饰的类成员属于类，不属于对象，因此static类成员函数是没有this指针的，this指针是指向本对象的指针。正因为没有this指针，所以static类成员函数不能访问非static的类成员，只能访问 static修饰的类成员；

\8) static成员函数不能被virtual修饰，static成员不属于任何对象或实例，所以加上virtual没有任何实际意义；静态成员函数没有this指针，虚函数的实现是为每一个对象分配一个vptr指针，而vptr是通过this指针调用的，所以不能为virtual；虚函数的调用关系，this->vptr->ctable->virtual function