内存重叠问题

![image-20211207125242341](image/image-20211207125242341.png)

第一种情况，拷贝重叠区域不会出现问题，内容均可以正确被拷贝。

第二种情况，问题出现在右边两个字节，这两个字节的原先内容一开始就被覆盖了，而且没有保存。所以接下来拷贝的时候，拷贝的是已经被覆盖的内容，显然是有问题的。



对于内存重叠第二种情况，该memcpy行为是未定义的，编译器可能会让程序崩溃，也可能只是复制结果不正确。



但是memmove有很好的考虑到内存重叠第二种情况会发生的问题，从后往前复制来避免拷贝到被覆盖的内容。



memmove在memcpy的基础上，很好解决了内存重叠问题，memmove开头加了一个分支，不重叠的时候走memcpy一样的代码。用memmove来代替memcpy，放在现在来设计标准库，只提供一个函数才是正确的设计，显然memcpy是历史包袱。



memcpy也不是一无是处。

当memcpy、memmove优化到极致，多一次两次判断对整体的性能影响是比较大的，特别是在流水线比较长的处理器体系中。

同时，内存复制的使用时非常频繁的，几个字节都用memcpy，多一条少一条分支判断都会影响总体性能。

同时，实际情况下，两个区域是否重叠往往是可预期的，真的重叠了，那应该是程序bug，此时未定义行为如果是程序崩溃反而是好事，提醒你这里有个bug，但未定义行为如果只是复制结果不正确，那隐藏的bug难以找出来。