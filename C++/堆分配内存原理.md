**堆的深入理解**

栈上的数据在函数返回时就会被释放掉，所以无法将数据传至函数外部，而全局变量没有办法动态地产生，只能在编译的时候定义，在这种情况下，堆是唯一地选择。malloc是C语言申请堆空间的函数，但是它是怎么实现的那？

其实可以直接让操作系统的内核来管理进程的内存，但是每次申请内存都要经过系统调用，如果操作频繁会导致效率很低，程序性能降低。比较好的做法是程序向操作系统申请一块适当的堆空间，然后由程序的运行库根据算法管理堆空间的分配，当堆空间不够的时候再向操作系统申请堆空间。linux下提供两种堆空间分配方式：**一个是brk（）系统调用，另外一个是mmap（）。**

```
int brk (void *end_data_segment)
```

brk()的作用实际上就是设置进程数据段的结束地址，她可以扩大或者缩小数据段。

```
void mmap（void *start, size_t length, int port, int flags, int fd, off_t offset）
```

mmap的前两个参数分别指定需要申请的空间的起始地址和长度，如果其实地址设为0，那么操作系统会挑选合适的起始地址。port/flags这两个参数用于设置申请的空间的权限（可读，可写，可执行）以及映射类型（文件类型，匿名空间等），最后两个参数用于文件映射是指定文件的描述符和文件偏移。用mmap实现的malloc函数：

```
void *malloc(size_t nbytes)
{
 void *ret = mmap(0, nbytes, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, 0 , 0);
 if (ret == MAP_FAILED)
 return 0;
 return ret;
}
```

**mmap（）的作用是向操作系统申请一段虚拟空间，当这块虚拟空间可以映射到某个文件（也就是这个系统调用的最初的作用），当他不将地址空间映射到某个文件时，我们又称这块空间为匿名空间。**

glibc的malloc 函数是这样处理用户的空间请求的：对于小于128KB的请求来说，它会在现有的堆空间里面，按照堆分配算法为它分配一块空间返回，对于大于128KB的请求来说，它会使用mmap（）函数为它分配一块匿名空间，然后再这个匿名空间中为用户分配空间。（所以问一个很常见的问题，malloc申请的内存，进程结束以后还会不会存在？ 答案是不存在）



**堆分配算法**

**1、空闲链表法**

空闲链表的方法是把堆中各个空闲的快按照链表的方式连接起来，当用户请求一块空间时，可以遍历整个列表，直到找到合适大小的快并且将它拆分，当用户释放空间时将它合并到空闲链表中。

**2、位图**

核心思想就是将整个堆划分为大量的块，每个块大小相同。当用户请求内存的时候总是分配整个块的空间给用户。第一个块我们称为已分配区域的头，其余的称为已分配区域的主体。而我们可以使用一个整数数组来记录块的使用情况，由于每个块只有头/主体/空闲三种状态，因此仅仅需要两位即可表示一个块，因此称为位图。

**优点：速度快，稳定性好，容易管理。**

**缺点：容易产生碎片，浪费空间。**

**3、对象池**

如果实际上在一些场合，被分配对象的大小是固定的几个值，我们可以采用对象池的方法。对象池思想就是，如果每一次分配的空间大小都一样，那么就可以按照这个每次请求分配的大小作为一个单位，把整个堆空间划分为大量的小块，每次请求只要找到一个空闲的小块就可以了。

**实际上很多应用中，堆的分配算法往往是采取多种算法复合而成的，对于glibc来说，小于64字节的采用对象池的方法，对于大于512字节的采用最佳适配算法，对于64字节和512字节之间的采取最佳折中策略；对于大于128kb的申请，它会直接使用mmap向操作系统申请空间。**