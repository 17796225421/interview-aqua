内存分配中的栈与堆主要存在如下区别。

### **1) 分配与释放方式**

栈内存是由编译器自动分配与释放的，它有两种分配方式：静态分配和动态分配。

- 静态分配是由编译器自动完成的，如局部变量的分配（即在一个函数中声明一个 int 类型的变量i时，编译器就会自动开辟一块内存以存放变量 i）。与此同时，其生存周期也只在函数的运行过程中，在运行后就释放，并不可以再次访问。
- 动态分配由 alloca 函数进行分配，但是栈的动态分配与堆是不同的，它的动态分配是由编译器进行释放，无需任何手工实现。值得注意的是，虽然用 alloca 函数可以实现栈内存的动态分配，但 alloca 函数的可移植性很差，而且在没有传统堆栈的机器上很难实现。因此，不宜使用于广泛移植的程序中。当然，完全可以使用 C99 中的变长数组来替代 alloca 函数。


而堆内存则不相同，它完全是由程序员手动申请与释放的，程序在运行的时候由程序员使用内存分配函数（如 malloc 函数）来申请任意多少的内存，使用完再由程序员自己负责使用内存释放函数（如 free 函数）释放内存，如下面的代码所示：



![0fa5140234f1984d29a27b2c34708ce3.png](image/0fa5140234f1984d29a27b2c34708ce3.png)

对栈内存的自动释放而言，虽然堆上的数据只要程序员不释放空间就可以一直访问，但是，如果一旦忘记了释放堆内存，那么将会造成内存泄漏，导致程序出现致命的潜在错误。

### **2) 分配的碎片问题**

对堆来说，频繁分配和释放（malloc / free）不同大小的堆空间势必会造成内存空间的不连续，从而造成大量碎片，导致程序效率降低；而对栈来讲，则不会存在这个问题。

### **3) 分配的效率**

大家都知道，栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，例如，分配专门的寄存器存放栈的地址，压栈出栈都有专门的执行指令，这就决定了栈的效率比较高。一般而言，只要栈的剩余空间大于所申请空间，系统就将为程序提供内存，否则将报异常提示栈溢出。
而堆则不同，它是由 C/C++ 函数库提供的，它的机制也相当复杂。例如，为了分配一块堆内存，首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆节点，然后将该节点从空闲节点链表中删除，并将该节点的空间分配给程序。而对于大多数系统，会在这块内存空间的首地址处记录本次分配的大小，这样，代码中的 delete 语句才能正确释放本内存空间。另外，由于找到的堆节点的大小不一定正好等于申请的大小，系统会自动将多余的那部分重新放入空闲链表中。很显然，堆的分配效率比栈要低得多。

### **4) 申请的大小限制**

由于操作系统是用链表来存储空闲内存地址（内存区域不连续）的，同时链表的遍历方向是由低地址向高地址进行的。因此，堆内存的申请大小受限于计算机系统中有效的虚拟内存。
而栈则不同，它是一块连续的内存区域，**其地址的增长方向是向下进行的，向内存地址减小的方向增长**。由此可见，栈顶的地址和栈的最大容量一般都是由系统预先规定好的，如果申请的空间超过栈的剩余空间时，将会提示溢出错误。由此可见，相对于堆，能够从栈中获得的空间相对较小。

### **5) 存储的内容**

对栈而言，一般用于存放函数的参数与局部变量等。例如，在函数调用时，第一个进栈的是（主函数中的）调用处的下一条指令（即函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，**在大多数 C 编译器中，参数是由右往左入栈的，最后是函数中的局部变量（注意 static 变量是不入栈的）**。

**对堆而言，具体存储内容由程序员根据需要决定存储数据。**



------

#### [5、堆和栈的区别](https://interviewguide.cn/#/Doc/Knowledge/C++/基础语法/基础语法?id=5、堆和栈的区别)

- 申请方式不同。
  - 栈由系统自动分配。
- 堆是自己申请和释放的。
- 申请大小限制不同。
  - 栈顶和栈底是之前预设好的，栈是向栈底扩展，大小固定，可以通过ulimit -a查看，由ulimit -s修改。
  - 堆向高地址扩展，是不连续的内存区域，大小可以灵活调整。
- 申请效率不同。
  - 栈由系统分配，速度快，不会有碎片。
  - 堆由程序员分配，速度慢，且会有碎片。

栈空间默认是4M, 堆区一般是 1G - 4G

|                  | 堆                                                           | 栈                                                           |
| ---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **管理方式**     | 堆中资源由程序员控制（容易产生memory leak）                  | 栈资源由编译器自动管理，无需手工控制                         |
| **内存管理机制** | 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） | 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了） |
| **空间大小**     | 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大 | 栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置） |
| **碎片问题**     | 对于堆，频繁的new/delete会造成大量碎片，使程序效率降低       | 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别） |
| **生长方向**     | 堆向上，向高地址方向增长。                                   | 栈向下，向低地址方向增长。                                   |
| **分配方式**     | 堆都是动态分配（没有静态分配的堆）                           | 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。 |
| **分配效率**     | 堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。    | 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。 |

**形象的比喻**

栈就像我们去饭馆里吃饭，只管点菜（发出申请）、付钱、和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。

堆就象是自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大。



#### [6、你觉得堆快一点还是栈快一点？](https://interviewguide.cn/#/Doc/Knowledge/C++/基础语法/基础语法?id=6、你觉得堆快一点还是栈快一点？)

毫无疑问是栈快一点。

因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。

而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。